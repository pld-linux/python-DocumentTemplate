diff -u -r -N ZTemplates-2.3.0-orig/DocumentTemplate/Makefile.pre.in ZTemplates-2.3.0/DocumentTemplate/Makefile.pre.in
--- ZTemplates-2.3.0-orig/DocumentTemplate/Makefile.pre.in	Wed Dec 31 16:00:00 1969
+++ ZTemplates-2.3.0/DocumentTemplate/Makefile.pre.in	Fri Jan 15 12:42:15 1999
@@ -0,0 +1,299 @@
+# Universal Unix Makefile for Python extensions
+# =============================================
+
+# Short Instructions
+# ------------------
+
+# 1. Build and install Python (1.5 or newer).
+# 2. "make -f Makefile.pre.in boot"
+# 3. "make"
+# You should now have a shared library.
+
+# Long Instructions
+# -----------------
+
+# Build *and install* the basic Python 1.5 distribution.  See the
+# Python README for instructions.  (This version of Makefile.pre.in
+# only withs with Python 1.5, alpha 3 or newer.)
+
+# Create a file Setup.in for your extension.  This file follows the
+# format of the Modules/Setup.in file; see the instructions there.
+# For a simple module called "spam" on file "spammodule.c", it can
+# contain a single line:
+#   spam spammodule.c
+# You can build as many modules as you want in the same directory --
+# just have a separate line for each of them in the Setup.in file.
+
+# If you want to build your extension as a shared library, insert a
+# line containing just the string
+#   *shared*
+# at the top of your Setup.in file.
+
+# Note that the build process copies Setup.in to Setup, and then works
+# with Setup.  It doesn't overwrite Setup when Setup.in is changed, so
+# while you're in the process of debugging your Setup.in file, you may
+# want to edit Setup instead, and copy it back to Setup.in later.
+# (All this is done so you can distribute your extension easily and
+# someone else can select the modules they actually want to build by
+# commenting out lines in the Setup file, without editing the
+# original.  Editing Setup is also used to specify nonstandard
+# locations for include or library files.)
+
+# Copy this file (Misc/Makefile.pre.in) to the directory containing
+# your extension.
+
+# Run "make -f Makefile.pre.in boot".  This creates Makefile
+# (producing Makefile.pre and sedscript as intermediate files) and
+# config.c, incorporating the values for sys.prefix, sys.exec_prefix
+# and sys.version from the installed Python binary.  For this to work,
+# the python binary must be on your path.  If this fails, try
+#   make -f Makefile.pre.in Makefile VERSION=1.5 installdir=<prefix>
+# where <prefix> is the prefix used to install Python for installdir
+# (and possibly similar for exec_installdir=<exec_prefix>).
+
+# Note: "make boot" implies "make clobber" -- it assumes that when you
+# bootstrap you may have changed platforms so it removes all previous
+# output files.
+
+# If you are building your extension as a shared library (your
+# Setup.in file starts with *shared*), run "make" or "make sharedmods"
+# to build the shared library files.  If you are building a statically
+# linked Python binary (the only solution of your platform doesn't
+# support shared libraries, and sometimes handy if you want to
+# distribute or install the resulting Python binary), run "make
+# python".
+
+# Note: Each time you edit Makefile.pre.in or Setup, you must run
+# "make Makefile" before running "make".
+
+# Hint: if you want to use VPATH, you can start in an empty
+# subdirectory and say (e.g.):
+#   make -f ../Makefile.pre.in boot srcdir=.. VPATH=..
+
+
+# === Bootstrap variables (edited through "make boot") ===
+
+# The prefix used by "make inclinstall libainstall" of core python
+installdir=	/usr/local
+
+# The exec_prefix used by the same
+exec_installdir=$(installdir)
+
+# Source directory and VPATH in case you want to use VPATH.
+# (You will have to edit these two lines yourself -- there is no
+# automatic support as the Makefile is not generated by
+# config.status.)
+srcdir=		.
+VPATH=		.
+
+# === Variables that you may want to customize (rarely) ===
+
+# (Static) build target
+TARGET=		python
+
+# Installed python binary (used only by boot target)
+PYTHON=		python
+
+# Add more -I and -D options here
+CFLAGS=		$(OPT) -I$(INCLUDEPY) -I$(EXECINCLUDEPY) $(DEFS)
+
+# These two variables can be set in Setup to merge extensions.
+# See example[23].
+BASELIB=	
+BASESETUP=	
+
+# === Variables set by makesetup ===
+
+MODOBJS=	_MODOBJS_
+MODLIBS=	_MODLIBS_
+
+# === Definitions added by makesetup ===
+
+# === Variables from configure (through sedscript) ===
+
+VERSION=	@VERSION@
+CC=		@CC@
+LINKCC=		@LINKCC@
+SGI_ABI=	@SGI_ABI@
+OPT=		@OPT@
+LDFLAGS=	@LDFLAGS@
+LDLAST=		@LDLAST@
+DEFS=		@DEFS@
+LIBS=		@LIBS@
+LIBM=		@LIBM@
+LIBC=		@LIBC@
+RANLIB=		@RANLIB@
+MACHDEP=	@MACHDEP@
+SO=		@SO@
+LDSHARED=	@LDSHARED@
+CCSHARED=	@CCSHARED@
+LINKFORSHARED=	@LINKFORSHARED@
+#@SET_CCC@
+
+# Install prefix for architecture-independent files
+prefix=		/usr/local
+
+# Install prefix for architecture-dependent files
+exec_prefix=	$(prefix)
+
+# === Fixed definitions ===
+
+# Shell used by make (some versions default to the login shell, which is bad)
+SHELL=		/bin/sh
+
+# Expanded directories
+BINDIR=		$(exec_installdir)/bin
+LIBDIR=		$(exec_prefix)/lib
+MANDIR=		$(installdir)/man
+INCLUDEDIR=	$(installdir)/include
+SCRIPTDIR=	$(prefix)/lib
+
+# Detailed destination directories
+BINLIBDEST=	$(LIBDIR)/python$(VERSION)
+LIBDEST=	$(SCRIPTDIR)/python$(VERSION)
+INCLUDEPY=	$(INCLUDEDIR)/python$(VERSION)
+EXECINCLUDEPY=	$(exec_installdir)/include/python$(VERSION)
+LIBP=		$(exec_installdir)/lib/python$(VERSION)
+DESTSHARED=	$(BINLIBDEST)/site-packages
+
+LIBPL=		$(LIBP)/config
+
+PYTHONLIBS=	$(LIBPL)/libpython$(VERSION).a
+
+MAKESETUP=	$(LIBPL)/makesetup
+MAKEFILE=	$(LIBPL)/Makefile
+CONFIGC=	$(LIBPL)/config.c
+CONFIGCIN=	$(LIBPL)/config.c.in
+SETUP=		$(LIBPL)/Setup
+
+SYSLIBS=	$(LIBM) $(LIBC)
+
+ADDOBJS=	$(LIBPL)/python.o config.o
+
+# Portable install script (configure doesn't always guess right)
+INSTALL=	$(LIBPL)/install-sh -c
+# Shared libraries must be installed with executable mode on some systems;
+# rather than figuring out exactly which, we always give them executable mode.
+# Also, making them read-only seems to be a good idea...
+INSTALL_SHARED=	${INSTALL} -m 555
+
+# === Fixed rules ===
+
+# Default target.  This builds shared libraries only
+default:	sharedmods
+
+# Build everything
+all:		static sharedmods
+
+# Build shared libraries from our extension modules
+sharedmods:	$(SHAREDMODS)
+
+# Build a static Python binary containing our extension modules
+static:		$(TARGET)
+$(TARGET):	$(ADDOBJS) lib.a $(PYTHONLIBS) Makefile $(BASELIB)
+		$(LINKCC) $(LDFLAGS) $(LINKFORSHARED) \
+		 $(ADDOBJS) lib.a $(PYTHONLIBS) \
+		 $(LINKPATH) $(BASELIB) $(MODLIBS) $(LIBS) $(SYSLIBS) \
+		 -o $(TARGET) $(LDLAST)
+
+install:	sharedmods
+		if test ! -d $(DESTSHARED) ; then \
+			mkdir $(DESTSHARED) ; else true ; fi
+		-for i in X $(SHAREDMODS); do \
+			if test $$i != X; \
+			then $(INSTALL_SHARED) $$i $(DESTSHARED)/$$i; \
+			fi; \
+		done
+
+# Build the library containing our extension modules
+lib.a:		$(MODOBJS)
+		-rm -f lib.a
+		ar cr lib.a $(MODOBJS)
+		-$(RANLIB) lib.a 
+
+# This runs makesetup *twice* to use the BASESETUP definition from Setup
+config.c Makefile:	Makefile.pre Setup $(BASESETUP) $(MAKESETUP)
+		$(MAKESETUP) \
+		 -m Makefile.pre -c $(CONFIGCIN) Setup -n $(BASESETUP) $(SETUP)
+		$(MAKE) -f Makefile do-it-again
+
+# Internal target to run makesetup for the second time
+do-it-again:
+		$(MAKESETUP) \
+		 -m Makefile.pre -c $(CONFIGCIN) Setup -n $(BASESETUP) $(SETUP)
+
+# Make config.o from the config.c created by makesetup
+config.o:	config.c
+		$(CC) $(CFLAGS) -c config.c
+
+# Setup is copied from Setup.in *only* if it doesn't yet exist
+Setup:
+		cp $(srcdir)/Setup.in Setup
+
+# Make the intermediate Makefile.pre from Makefile.pre.in
+Makefile.pre: Makefile.pre.in sedscript
+		sed -f sedscript $(srcdir)/Makefile.pre.in >Makefile.pre
+
+# Shortcuts to make the sed arguments on one line
+P=prefix
+E=exec_prefix
+H=Generated automatically from Makefile.pre.in by sedscript.
+L=LINKFORSHARED
+
+# Make the sed script used to create Makefile.pre from Makefile.pre.in
+sedscript:	$(MAKEFILE)
+	sed -n \
+	 -e '1s/.*/1i\\/p' \
+	 -e '2s%.*%# $H%p' \
+	 -e '/^VERSION=/s/^VERSION=[ 	]*\(.*\)/s%@VERSION[@]%\1%/p' \
+	 -e '/^CC=/s/^CC=[ 	]*\(.*\)/s%@CC[@]%\1%/p' \
+	 -e '/^CCC=/s/^CCC=[ 	]*\(.*\)/s%#@SET_CCC[@]%CCC=\1%/p' \
+	 -e '/^LINKCC=/s/^LINKCC=[ 	]*\(.*\)/s%@LINKCC[@]%\1%/p' \
+	 -e '/^OPT=/s/^OPT=[ 	]*\(.*\)/s%@OPT[@]%\1%/p' \
+	 -e '/^LDFLAGS=/s/^LDFLAGS=[ 	]*\(.*\)/s%@LDFLAGS[@]%\1%/p' \
+	 -e '/^DEFS=/s/^DEFS=[ 	]*\(.*\)/s%@DEFS[@]%\1%/p' \
+	 -e '/^LIBS=/s/^LIBS=[ 	]*\(.*\)/s%@LIBS[@]%\1%/p' \
+	 -e '/^LIBM=/s/^LIBM=[ 	]*\(.*\)/s%@LIBM[@]%\1%/p' \
+	 -e '/^LIBC=/s/^LIBC=[ 	]*\(.*\)/s%@LIBC[@]%\1%/p' \
+	 -e '/^RANLIB=/s/^RANLIB=[ 	]*\(.*\)/s%@RANLIB[@]%\1%/p' \
+	 -e '/^MACHDEP=/s/^MACHDEP=[ 	]*\(.*\)/s%@MACHDEP[@]%\1%/p' \
+	 -e '/^SO=/s/^SO=[ 	]*\(.*\)/s%@SO[@]%\1%/p' \
+	 -e '/^LDSHARED=/s/^LDSHARED=[ 	]*\(.*\)/s%@LDSHARED[@]%\1%/p' \
+	 -e '/^CCSHARED=/s/^CCSHARED=[ 	]*\(.*\)/s%@CCSHARED[@]%\1%/p' \
+	 -e '/^$L=/s/^$L=[ 	]*\(.*\)/s%@$L[@]%\1%/p' \
+	 -e '/^$P=/s/^$P=\(.*\)/s%^$P=.*%$P=\1%/p' \
+	 -e '/^$E=/s/^$E=\(.*\)/s%^$E=.*%$E=\1%/p' \
+	 $(MAKEFILE) >sedscript
+	echo "/^#@SET_CCC@/d" >>sedscript
+	echo "/^installdir=/s%=.*%=	$(installdir)%" >>sedscript
+	echo "/^exec_installdir=/s%=.*%=$(exec_installdir)%" >>sedscript
+	echo "/^srcdir=/s%=.*%=		$(srcdir)%" >>sedscript
+	echo "/^VPATH=/s%=.*%=		$(VPATH)%" >>sedscript
+	echo "/^LINKPATH=/s%=.*%=	$(LINKPATH)%" >>sedscript
+	echo "/^BASELIB=/s%=.*%=	$(BASELIB)%" >>sedscript
+	echo "/^BASESETUP=/s%=.*%=	$(BASESETUP)%" >>sedscript
+
+# Bootstrap target
+boot:	clobber
+	VERSION=`$(PYTHON) -c "import sys; print sys.version[:3]"`; \
+	installdir=`$(PYTHON) -c "import sys; print sys.prefix"`; \
+	exec_installdir=`$(PYTHON) -c "import sys; print sys.exec_prefix"`; \
+	$(MAKE) -f $(srcdir)/Makefile.pre.in VPATH=$(VPATH) srcdir=$(srcdir) \
+		VERSION=$$VERSION \
+		installdir=$$installdir \
+		exec_installdir=$$exec_installdir \
+		Makefile
+
+# Handy target to remove intermediate files and backups
+clean:
+		-rm -f *.o *~
+
+# Handy target to remove everything that is easily regenerated
+clobber:	clean
+		-rm -f *.a tags TAGS config.c Makefile.pre $(TARGET) sedscript
+		-rm -f *.so *.sl so_locations
+
+
+# Handy target to remove everything you don't want to distribute
+distclean:	clobber
+		-rm -f Makefile Setup
diff -u -r -N ZTemplates-2.3.0-orig/DocumentTemplate/Setup ZTemplates-2.3.0/DocumentTemplate/Setup
--- ZTemplates-2.3.0-orig/DocumentTemplate/Setup	Wed Dec 31 16:00:00 1969
+++ ZTemplates-2.3.0/DocumentTemplate/Setup	Fri Jan 15 12:47:43 1999
@@ -0,0 +1,5 @@
+*shared*
+
+cDocumentTemplate cDocumentTemplate.c -I../required
+
+
diff -u -r -N ZTemplates-2.3.0-orig/required/ExtensionClass.h ZTemplates-2.3.0/required/ExtensionClass.h
--- ZTemplates-2.3.0-orig/required/ExtensionClass.h	Wed Dec 31 16:00:00 1969
+++ ZTemplates-2.3.0/required/ExtensionClass.h	Fri Jan 15 12:46:50 1999
@@ -0,0 +1,448 @@
+/*
+
+  $Id$
+
+  Extension Class Definitions
+
+  Copyright (c) 1996-1998, Digital Creations, Fredericksburg, VA, USA.  
+  All rights reserved.
+  
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+    
+      o Redistributions of source code must retain the above copyright
+	notice, this list of conditions, and the disclaimer that follows.
+    
+      o Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions, and the following disclaimer in
+	the documentation and/or other materials provided with the
+	distribution.
+    
+      o Neither the name of Digital Creations nor the names of its
+	contributors may be used to endorse or promote products derived
+	from this software without specific prior written permission.
+    
+    
+    THIS SOFTWARE IS PROVIDED BY DIGITAL CREATIONS AND CONTRIBUTORS *AS
+    IS* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DIGITAL
+    CREATIONS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+    DAMAGE.
+
+  Implementing base extension classes
+  
+    A base extension class is implemented in much the same way that an
+    extension type is implemented, except:
+  
+    - The include file, 'ExtensionClass.h', must be included.
+ 
+    - The type structure is declared to be of type
+	  'PyExtensionClass', rather than of type 'PyTypeObject'.
+ 
+    - The type structure has an additional member that must be defined
+	  after the documentation string.  This extra member is a method chain
+	  ('PyMethodChain') containing a linked list of method definition
+	  ('PyMethodDef') lists.  Method chains can be used to implement
+	  method inheritance in C.  Most extensions don't use method chains,
+	  but simply define method lists, which are null-terminated arrays
+	  of method definitions.  A macro, 'METHOD_CHAIN' is defined in
+	  'ExtensionClass.h' that converts a method list to a method chain.
+	  (See the example below.)
+  
+    - Module functions that create new instances must be replaced by an
+	  '__init__' method that initializes, but does not create storage for 
+	  instances.
+  
+    - The extension class must be initialized and exported to the module
+	  with::
+  
+	      PyExtensionClass_Export(d,"name",type);
+  
+	  where 'name' is the module name and 'type' is the extension class
+	  type object.
+  
+    Attribute lookup
+  
+	  Attribute lookup is performed by calling the base extension class
+	  'getattr' operation for the base extension class that includes C
+	  data, or for the first base extension class, if none of the base
+	  extension classes include C data.  'ExtensionClass.h' defines a
+	  macro 'Py_FindAttrString' that can be used to find an object's
+	  attributes that are stored in the object's instance dictionary or
+	  in the object's class or base classes::
+  
+	     v = Py_FindAttrString(self,name);
+  
+	  In addition, a macro is provided that replaces 'Py_FindMethod'
+	  calls with logic to perform the same sort of lookup that is
+	  provided by 'Py_FindAttrString'.
+  
+    Linking
+  
+	  The extension class mechanism was designed to be useful with
+	  dynamically linked extension modules.  Modules that implement
+	  extension classes do not have to be linked against an extension
+	  class library.  The macro 'PyExtensionClass_Export' imports the
+	  'ExtensionClass' module and uses objects imported from this module
+	  to initialize an extension class with necessary behavior.
+ 
+  If you have questions regarding this software,
+  contact:
+ 
+  
+  If you have questions regarding this software,
+  contact:
+ 
+    Digital Creations L.C.  
+    info@digicool.com
+ 
+    (540) 371-6909
+
+*/
+
+#ifndef EXTENSIONCLASS_H
+#define EXTENSIONCLASS_H
+
+#include "Python.h"
+#include "import.h"
+
+/* Declarations for objects of type ExtensionClass */
+
+typedef struct {
+	PyObject_VAR_HEAD
+	char *tp_name; /* For printing */
+	int tp_basicsize, tp_itemsize; /* For allocation */
+	
+	/* Methods to implement standard operations */
+	
+	destructor tp_dealloc;
+	printfunc tp_print;
+	getattrfunc tp_getattr;
+	setattrfunc tp_setattr;
+	cmpfunc tp_compare;
+	reprfunc tp_repr;
+	
+	/* Method suites for standard classes */
+	
+	PyNumberMethods *tp_as_number;
+	PySequenceMethods *tp_as_sequence;
+	PyMappingMethods *tp_as_mapping;
+
+	/* More standard operations (at end for binary compatibility) */
+
+	hashfunc tp_hash;
+	ternaryfunc tp_call;
+	reprfunc tp_str;
+	getattrofunc tp_getattro;
+	setattrofunc tp_setattro;
+	/* Space for future expansion */
+	long tp_xxx3;
+	long tp_xxx4;
+
+	char *tp_doc; /* Documentation string */
+
+#ifdef COUNT_ALLOCS
+	/* these must be last */
+	int tp_alloc;
+	int tp_free;
+	int tp_maxalloc;
+	struct _typeobject *tp_next;
+#endif
+
+  /* Here's the juicy stuff: */
+
+  /* Put your method chain here.  If you just have a method
+     list, you can use the METHON_CHAIN macro to make a chain.
+     */
+  PyMethodChain methods;
+
+  /* You may set certain flags here. */
+  long class_flags;
+
+  /* The following flags are used by ExtensionClass */
+#define EXTENSIONCLASS_DYNAMIC_FLAG       1 << 0
+#define EXTENSIONCLASS_BINDABLE_FLAG      1 << 2
+#define EXTENSIONCLASS_METHODHOOK_FLAG    1 << 3
+#define EXTENSIONCLASS_INSTDICT_FLAG      1 << 4
+#define EXTENSIONCLASS_NOINSTDICT_FLAG    1 << 5
+#define EXTENSIONCLASS_BASICNEW_FLAG      1 << 6
+
+  /* The following flags are for use by extension class developers. */
+#define EXTENSIONCLASS_USER_FLAG1  	  1 << 16
+#define EXTENSIONCLASS_USER_FLAG2  	  1 << 17
+#define EXTENSIONCLASS_USER_FLAG3  	  1 << 18
+#define EXTENSIONCLASS_USER_FLAG4  	  1 << 19
+#define EXTENSIONCLASS_USER_FLAG5  	  1 << 20
+#define EXTENSIONCLASS_USER_FLAG6  	  1 << 21
+#define EXTENSIONCLASS_USER_FLAG7  	  1 << 22
+#define EXTENSIONCLASS_USER_FLAG8  	  1 << 23
+#define EXTENSIONCLASS_USER_FLAG9  	  1 << 24
+#define EXTENSIONCLASS_USER_FLAG10 	  1 << 25
+#define EXTENSIONCLASS_USER_FLAG11 	  1 << 26
+#define EXTENSIONCLASS_USER_FLAG12 	  1 << 27
+#define EXTENSIONCLASS_USER_FLAG13 	  1 << 28
+#define EXTENSIONCLASS_USER_FLAG14 	  1 << 29
+#define EXTENSIONCLASS_USER_FLAG15 	  1 << 30
+#define EXTENSIONCLASS_USER_FLAG16 	  1 << 31
+
+  /* This is the class dictionary, which is normally created for you.
+     If you wish, you can provide your own class dictionary object.
+     If you do provide your own class dictionary, it *must* be
+     a mapping object.  If the object given is also an extension
+     instance, then sub-class instance dictionaries will be created
+     by calling the class dictionary's class with zero argumemts.
+     Otherwise, subclass dictionaries will be of the default type.
+     */
+  PyObject *class_dictionary;
+
+  /* You should not set the remaining members. */
+  PyObject *bases;
+  PyObject *reserved;
+} PyExtensionClass;
+
+/* Following are macros that are needed or useful for defining extension
+   classes:
+   */
+
+/* This macro redefines Py_FindMethod to do attribute for an attribute
+   name given by a C string lookup using extension class meta-data.
+   This is used by older getattr implementations.
+
+   This macro is used in base class implementations of tp_getattr to
+   lookup methods or attributes that are not managed by the base type
+   directly.  The macro is generally used to search for attributes
+   after other attribute searches have failed.
+   
+   Note that in Python 1.4, a getattr operation may be provided that
+   uses an object argument. Classes that support this new operation
+   should use Py_FindAttr.
+   */
+#define Py_FindMethod(M,SELF,NAME) \
+  (PyExtensionClassCAPI->getattrs((SELF),(NAME)))
+
+/* Do method or attribute lookup for an attribute name given by a C
+   string using extension class meta-data.
+
+   This macro is used in base class implementations of tp_getattro to
+   lookup methods or attributes that are not managed by the base type
+   directly.  The macro is generally used to search for attributes
+   after other attribute searches have failed.
+   
+   Note that in Python 1.4, a getattr operation may be provided that
+   uses an object argument. Classes that support this new operation
+   should use Py_FindAttr.
+   */
+#define Py_FindAttrString(SELF,NAME) \
+  (PyExtensionClassCAPI->getattrs((SELF),(NAME)))
+
+/* Do method or attribute lookup using extension class meta-data.
+
+   This macro is used in base class implementations of tp_getattr to
+   lookup methods or attributes that are not managed by the base type
+   directly.  The macro is generally used to search for attributes
+   after other attribute searches have failed.  */
+#define Py_FindAttr(SELF,NAME) (PyExtensionClassCAPI->getattro((SELF),(NAME)))
+
+/* Do method or attribute assignment for an attribute name given by a
+   C string using extension class meta-data.
+
+   This macro is used in base class implementations of tp_setattr to
+   set attributes that are not managed by the base type directly.  The
+   macro is generally used to assign attributes after other attribute
+   attempts to assign attributes have failed.
+
+   Note that in Python 1.4, a setattr operation may be provided that
+   uses an object argument. Classes that support this new operation
+   should use PyEC_SetAttr.
+   */
+#define PyEC_SetAttrString(SELF,NAME,V) \
+  (PyExtensionClassCAPI->setattrs((SELF),(NAME),(V)))
+
+/* Do attribute assignment for an attribute.
+
+   This macro is used in base class implementations of tp_setattro to
+   set attributes that are not managed by the base type directly.  The
+   macro is generally used to assign attributes after other attribute
+   attempts to assign attributes have failed.
+   */
+#define PyEC_SetAttr(SELF,NAME,V) \
+     (PyExtensionClassCAPI->setattro((SELF),(NAME),(V)))
+
+/* Import the ExtensionClass CAPI */
+#define ExtensionClassImported \
+  (PyExtensionClassCAPI=PyCObject_Import("ExtensionClass","CAPI"))
+
+/* Make sure the C interface has been imported and import it if necessary.
+   This can be used in an if.
+   */
+#define MakeSureExtensionClassImported \
+  (PyExtensionClassCAPI || \
+   (PyExtensionClassCAPI=PyCObject_Import("ExtensionClass","CAPI")))
+
+
+/* Export an Extension Base class in a given module dictionary with a
+   given name and ExtensionClass structure.
+   */
+#define PyExtensionClass_Export(D,N,T) \
+ if(PyExtensionClassCAPI || \
+   (PyExtensionClassCAPI= PyCObject_Import("ExtensionClass","CAPI"))) \
+   { PyExtensionClassCAPI->Export(D,N,&T); }
+
+/* Convert a method list to a method chain.  */
+#define METHOD_CHAIN(DEF) { DEF, NULL }
+
+/* The following macro checks whether a type is an extension class: */
+#define PyExtensionClass_Check(TYPE) \
+  ((PyObject*)(TYPE)->ob_type==PyExtensionClassCAPI->ExtensionClassType)
+
+/* The following macro checks whether an instance is an extension instance: */
+#define PyExtensionInstance_Check(INST) \
+  ((PyObject*)(INST)->ob_type->ob_type== \
+     PyExtensionClassCAPI->ExtensionClassType)
+
+/* The following macro checks for errors and prints out an error
+   message that is more informative than the one given by Python when
+   an extension module initialization fails.
+   */
+#define CHECK_FOR_ERRORS(MESS) \
+if(PyErr_Occurred()) { \
+  PyObject *__sys_exc_type, *__sys_exc_value, *__sys_exc_traceback; \
+  PyErr_Fetch( &__sys_exc_type, &__sys_exc_value, \
+	       &__sys_exc_traceback); \
+  fprintf(stderr, # MESS ":\n\t"); \
+  PyObject_Print(__sys_exc_type, stderr,0); \
+  fprintf(stderr,", "); \
+  PyObject_Print(__sys_exc_value, stderr,0); \
+  fprintf(stderr,"\n"); \
+  fflush(stderr); \
+  Py_FatalError(# MESS); \
+}
+
+/* The following macro can be used to define an extension base class
+   that only provides method and that is used as a pure mix-in class. */
+#define PURE_MIXIN_CLASS(NAME,DOC,METHODS) \
+static PyExtensionClass NAME ## Type = { PyObject_HEAD_INIT(NULL) \
+	0, # NAME, sizeof(PyPureMixinObject), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	0, 0, 0, 0, 0, 0, 0, DOC, {METHODS, NULL}, \
+        EXTENSIONCLASS_BASICNEW_FLAG}
+
+/* The following macros provide limited access to extension-class
+   method facilities. */
+
+/* Test for an ExtensionClass method: */
+#define PyECMethod_Check(O) \
+  ((PyObject*)(O)->ob_type==PyExtensionClassCAPI->MethodType)
+
+/* Create a method object that wraps a callable object and an
+   instance. Note that if the callable object is an extension class
+   method, then the new method will wrap the callable object that is
+   wrapped by the extension class method.  Also note that if the
+   callable object is an extension class method with a reference
+   count of 1, then the callable object will be rebound to the
+   instance and returned with an incremented reference count.
+   */
+#define PyECMethod_New(CALLABLE,INST) \
+  (PyExtensionClassCAPI->Method_New(CALLABLE,INST))
+
+/* Return the instance that is bound by an extension class method. */
+#define PyECMethod_Self(M) (((PyECMethodObject*)M)->self)
+
+/* Check whether an object has an __of__ method for returning itself
+   in the context of it's container. */
+#define has__of__(O) \
+   ((O)->ob_type->ob_type == \
+        (PyTypeObject*)PyExtensionClassCAPI->ExtensionClassType && \
+    (((PyExtensionClass*)((O)->ob_type))->class_flags & \
+     EXTENSIONCLASS_BINDABLE_FLAG))
+
+/* The following macros are used to check whether an instance
+   or a class' instanses have instance dictionaries: */
+#define HasInstDict(O) \
+   ((((PyExtensionClass*)((O)->ob_type))->class_flags & \
+     EXTENSIONCLASS_INSTDICT_FLAG))
+#define ClassHasInstDict(O) (O->class_flags & EXTENSIONCLASS_INSTDICT_FLAG)
+
+/* Get an object's instance dictionary.  Use with caution */
+#define INSTANCE_DICT(inst) \
+*(((PyObject**)inst) + (inst->ob_type->tp_basicsize/sizeof(PyObject*) - 1))
+
+/* Test whether an ExtensionClass, S, is a subclass of ExtensionClass C. */
+#define ExtensionClassSubclass_Check(S,C) ( \
+  ((PyObject*)(S)->ob_type==PyExtensionClassCAPI->ExtensionClassType) && \
+  ((PyObject*)(C)->ob_type==PyExtensionClassCAPI->ExtensionClassType) && \
+  (PyExtensionClassCAPI->issubclass((PyExtensionClass *)(S), \
+				    (PyExtensionClass *)(C))))
+
+/* Test whether an ExtensionClass instance , I, is a subclass of 
+   ExtensionClass C. */
+#define ExtensionClassSubclassInstance_Check(I,C) ( \
+  ((PyObject*)(I)->ob_type->ob_type== \
+                             PyExtensionClassCAPI->ExtensionClassType) && \
+  ((PyObject*)(C)->ob_type==PyExtensionClassCAPI->ExtensionClassType) && \
+  (PyExtensionClassCAPI->issubclass((PyExtensionClass *)((I)->ob_type), \
+				    (PyExtensionClass *)(C))))
+
+/* This let's you define built-in class methods. */
+#define METH_CLASS_METHOD (2 << 17)
+
+/*****************************************************************************
+
+  WARNING: EVERYTHING BELOW HERE IS PRIVATE TO THE EXTENSION CLASS INTERFACE
+           IMPLEMENTATION AND IS SUBJECT TO CHANGE !!!
+
+ *****************************************************************************/
+
+static struct ExtensionClassCAPIstruct {
+  int (*Export)(PyObject *dict, char *name, PyExtensionClass *ob_type);
+  PyObject *(*getattrs)(PyObject *, char *);
+  PyObject *(*getattro)(PyObject *, PyObject *);
+  int (*setattrs)(PyObject *, char *, PyObject *);
+  int (*setattro)(PyObject *, PyObject *, PyObject *);
+  PyObject *ExtensionClassType;
+  PyObject *MethodType;
+  PyObject *(*Method_New)(PyObject *callable, PyObject *inst);
+  int (*issubclass)(PyExtensionClass *sub, PyExtensionClass *type);
+} *PyExtensionClassCAPI = NULL;
+
+typedef struct { PyObject_HEAD } PyPureMixinObject;
+
+typedef struct {
+  PyObject_HEAD
+  PyTypeObject *type;
+  PyObject     *self;
+  PyObject     *meth;
+} PyECMethodObject;
+
+/* The following is to avoid whining from 1.5 :-) */
+#define PyCObject_Import PyCObject_Import14
+
+static void *
+PyCObject_Import14(char *module_name, char *name)
+{
+  PyObject *m, *c;
+  void *r=NULL;
+  
+  if((m=PyImport_ImportModule(module_name)))
+    {
+      if((c=PyObject_GetAttrString(m,name)))
+	{
+	  r=PyCObject_AsVoidPtr(c);
+	  Py_DECREF(c);
+	}
+      Py_DECREF(m);
+    }
+
+  return r;
+}
+
+#endif
+
+
